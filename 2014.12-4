/*
问题描述
　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。
　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。
　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。
输入格式
　　输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。
　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。
输出格式
　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。
样例输入
4 4
1 2 1
2 3 4
2 4 2
3 4 3
样例输出
6
样例说明
　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。
评测用例规模与约定
　　前20%的评测用例满足：n≤5。
　　前40%的评测用例满足：n≤20。
　　前60%的评测用例满足：n≤100。
　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。
*/

#include<iostream>
#include<vector>

/*
很明显这是一道求最小生成树的题目，最小生成树是这样一颗树，它包含了图的所有顶点且边的权值之和最小，常用的算法是prim算法和kruskal算法
这里用Prim算法，Prim算法就是贪心，每一步都选一条与已有点相连的最短路径 
*/
  
using namespace std;

vector< vector<int> > field(1001,vector<int>(1001, 10001)); //field[i][j]的值表示i到j的花费，10001表示不通 , 用二维vector不用数组的原因是二维vector可以直接取出一行方便后面用 
//注意用二维vector的时候两个右尖括号之间得有空格，要不没法编译
int visited[1001] = {0};

int main(){
	int m,n;
	cin>>n>>m;
	int x,y,cost;
	for(int i = 1; i <= m; i++){
		cin>>x>>y>>cost; 
		field[x][y] = cost;
		field[y][x] = cost;
	}
	visited[1] = 1;
	int min = 10001, sum = 0, temp; 
	vector<int> v = field[1]; // v[i]存储目前已访问过的点到 i点的最短距离 , 首先初始化为起始点到其他点的距离 
	for(int i = 1; i < n; i++){//n个点需要n-1条边连起来 
	  min = 10001; //每次循环都得记得重置min为最大值
		for(int j = 1; j < n + 1; j++){
			if(!visited[j] && min > v[j]){ //先找到目前v里的最小值v[j]，那么下一步就应该走到j点了 , 用temp把j存起来 
				min = v[j];
				temp = j;
			}	
		}
		sum += min; //把到j的花费加上，j置为已访问 
		visited[temp] = 1;
		for(int k = 1; k < n + 1; k++){ //由于新加了j点进来，需要维护v保证v[i]是目前已访问过的点到 i点的最短距离，所以遍历j到每个k点的距离，如果比现在的v[k]小就更新v[k] 
			if(!visited[k] && field[temp][k] < v[k]){
				v[k] = field[temp][k];
			}
		}
	} 
	cout<<sum<<endl;
	cin.get(); 
	return 0;
}

