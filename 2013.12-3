/*
在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。

　　请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。
输入格式
　　第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。
　　第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。
　　这里写图片描述
输出格式
　　输出一行，包含一个整数，即给定直方图内的最大矩形的面积。
样例输入
6
3 1 6 5 2 3

样例输出
10
*/

//暴力枚举法,枚举所有可能的矩形，左边界和右边界都可以是任意一个位置，用两重循环模拟，然后找到这个边界范围内最矮的作为高计算面积 
#include<iostream>
using namespace std;
int main(){
	int n;
	cin>>n;
	int rectangle[1001];
	int area = 0;
	int ans = 0;
	for(int i = 1; i <= n; i++){
		cin>>rectangle[i];
	}
	for(int i = 1; i <= n ;i++){ //注意循环的值，要包含每一个可能的矩形，单个的矩形也要包含在内，所以两重循环的值都是1到n
		int v = rectangle[i]; //这先把值存起来下面就好比较了 
		for(int j = i; j <= n; j++){
			v = min(v,rectangle[j]);  //因为第一重已经存了开始值，那么第二重就一定是范围内找到的最小值，否则就变成只比较了两个边界的高度 
			area = v * (j-i+1);
			ans = max(ans, area); 
		}
	}
	cout<<ans<<endl;
	cin.get();
	return 0;
} 
