/*
问题描述

　　我们把一个数称为有趣的，当且仅当：
　　1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。
　　2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。
　　3. 最高位数字不为0。
　　因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。
　　请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。

输入格式
　　输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。

输出格式
　　输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。

样例输入
4

样例输出
3
*/
/*
这是典型的动态规划（DP）问题，如果一个问题满足以下两点，那么它就能用动态规划解决。
1.问题的答案依赖于问题的规模，也就是问题的所有答案构成了一个数列。举个简单的例子，1个人有2条腿，2个人有4条腿，..，n个人有多少条腿?答案是2n条腿。这里的2n是问题的答案，n则是问题的规模，
显然问题的答案是依赖于问题的规模的。答案是因变量，问题规模是自变量。因此，问题在所有规模下的答案可以构成一个数列(f(1),f(2)…,f(n))，比如刚刚“数腿”的例子就构成了间隔为2的等差数列
(0,2,4,···,2n)。
2.大规模问题的答案可以由小规模问题的答案递推得到，也就是f(n)的值可以由ff(i)i<n中的个别求得。还是刚刚“数腿”的例子，显然f(n) 可以基于 f(n-1)求得：f(n)=f(n-1)+2。
*/
/*
应用动态规划——将动态规划拆分成三个子目标
当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标。
1.建立状态转移方程
这一步是最难的，大部分人都被卡在这里。这一步没太多的规律可说，只需抓住一个思维：
当做已经知道f(1）~f（n-1)的值，然后想办法利用它们求得f(n)。在“数腿”的例子中，状态转移方程即为f(n)=f(n-1)+2。
2.缓存并复用以往结果
这一步不难，但是很重要。如果没有合适地处理，很有可能就是指数和线性时间复杂度的区别。假设在“数腿”的例子中，我们不能用显式方程，只能用状态转移方程来解。
如果现在f(100)未知，但是刚刚求解过一次f(99)。如果不将其缓存起来，那么求f(100)时，我们就必须花100次加法运算重新获取。但是如果刚刚缓存过，只需复用这个子结果，
那么将只需一次加法运算即可。
3.按顺序从小往大算这里的“小”和“大”对应的是问题的规模，在这里也就是我们要从f(0)，f(1).到f(n)依次顺序计算。这一点在“数腿”的例子来看，似乎显而易见，
因为状态方程基本限制了你只能从小到大一步步递推出最终的结果（假设我们仍然不能用显式方程）。然而当问题复杂起来的时候，你有可能乱了套，所以必须记住这也是目标之一。
*/

/*开始写代码之前，我们先来分析一下这道题，最重要的步骤就是建立状态转移方程，那么我们首先就是要考虑一共有几个状态，再考虑状态之间的转换。
根据题意我们有4种数字：0，1，2，3，我们考虑从数字的种类来分：
假如我们的答案中只含一种数字，那么只能含有2才符合要求，可以是2，22，222···等等
如果是两种数字呢？可以包含2和0 或者2和3
三种数字可以有2、0、1 或2、0、3
四种数字当然就是0、1、2、3都包含啦
那么我们知道这道题总共就是6种状态了，注意我们考虑的是所有可能的情况噢，这些状态有一些是不符合要求的（因为题目实际要求了必须同时含有4种数字），
但我们首先也要把这个题的所有可能性列出来然后再考虑状态之间的转移，就算其他的状态不符合题意，它们也可以作为我们得到正确答案之前的中间状态，只要最后转移到符合要求的状态就好啦。

将n个数字组成的有趣数的个数记为g(n)
需要明确：任何一个n位有趣数，都可以看做是n-1位数，再在其后面追加0-3其中一个数而组成的
在这个组合过程中，有以下两种情况：

情况1：n-1个数组成的是有趣数，增加一个后还是有趣数
情况2：n-1个数组成的不是有趣数，增加一个后成了有趣数
对于情况1，前n-1位数是由0,1,2,3组成的有趣数，末尾追加1或3（因为要满足有趣数的定义，最后一位不可能是0或2）

对于情况2，又分为几种情况:

情况2.1：前n-1位数由0，1，2组成的类有趣数，末尾追加3
情况2.2：前n-1位数由0，2，3组成的类有趣数，末尾追加1
（这里的类有趣数指0-3没有全出现且"有1必有0，有3必有2"的数，简单说就是在末尾加上1或3能够构成有趣数的数）
因此，可以得出结论，g(n)和g(n-1)的关系不只与n有关，还与前n-1位数的状态有关，用一维参数变量就很难表示其递推关系了，所以需用二维参数，
我们再记f(n,s)为n位数状态s下的"类有趣数"的个数。而当状态s为0-3都至少出现一次时，也就是四个数都出现过的"类有趣数"，就是我们所求的有趣数。
记状态0：由2组成
状态1：由2,0组成
状态2：由2,3组成
状态3：由0,1,2组成
状态4：由0,2,3组成
状态5：由0,1,2,3组成（此时为有趣数）

即我们所要求的是f(n,5)的值

显然f(n,5) = 2 × f(n-1,5) + f(n-1,3) + f(n-1,4)
（状态5时在末尾可以追加1、3，状态3时可以追加3，状态4时可以追加1，所有分别乘2、1、1）
类推分别得出f(n,4)f(n,3)f(n,2)f(n,1)：
f(n,4) = 2 × f(n-1,4) + f(n-1,1) + f(n-1,2)
f(n,3) = 2 × f(n-1,3) + f(n-1,1)
f(n,2) = f(n-1,2) + f(n-1,0)
f(n,1) = 2 × f(n-1,1) + f(n-1,0)
f(n,0) = 1
注意状态转移不要遗忘从本状态转移到本状态的情况噢
终于可以开始写代码啦！
*/
#include<iostream>
#define PRIME 1000000007
using namespace std;
int main(){
	int n;
	cin>>n;
	long long f[1001][6] = {0};//因为n最大为1000，6种状态， f(n,6)最大需要1001*6的数组存储 注意到数字的范围超过了int，建议用long 
	for(int i = 1; i <= n; i++){  
		f[i][0] = 1;
		f[i][1] = (2 * f[i-1][1] + f[i-1][0]) % PRIME;
		f[i][2] = (f[i-1][2] + f[i-1][0]) % PRIME;
		f[i][3] = (2 * f[i-1][3] + f[i-1][1]) % PRIME;
		f[i][4] = (2 * f[i-1][4] + f[i-1][1] + f[i-1][2]) % PRIME;
		f[i][5] = (2 * f[i-1][5] + f[i-1][3] + f[i-1][4]) % PRIME;
	} 
	cout<<f[n][5]<<endl;
	cin.get();
	return 0;
} 
